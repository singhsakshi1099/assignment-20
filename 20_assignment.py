# -*- coding: utf-8 -*-
"""20 assignment

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eyqkjApHu59ubDIaJM-86ZuDlt886ZlX
"""

#1solution

Input:
       1
     /   \
   2       3
  / \     / \
 4   5   6   7




Input:
       1
     /   \
   -2      3
  / \     / \
 4   5  -6   2




   -2
  / \
 4   5

#2solution

class Node:
    def __init__(self, value):
        self.val = value
        self.left = None
        self.right = None


def constructBST(level_order):
    if not level_order:
        return None

    root = Node(level_order[0])
    queue = [root]
    i = 1

    while i < len(level_order):
        current = queue.pop(0)
        left_val = level_order[i]
        i += 1

        if left_val != None:
            left_node = Node(left_val)
            current.left = left_node
            queue.append(left_node)

        if i >= len(level_order):
            break

        right_val = level_order[i]
        i += 1

        if right_val != None:
            right_node = Node(right_val)
            current.right = right_node
            queue.append(right_node)

    return root


def inorderTraversal(node):
    if node is None:
        return []

    traversal = []
    traversal.extend(inorderTraversal(node.left))
    traversal.append(node.val)
    traversal.extend(inorderTraversal(node.right))

    return traversal



level_order = [7, 4, 12, 3, 6, 8, 1, 5, 10]
bst_root = constructBST(level_order)
inorder = inorderTraversal(bst_root)
print("BST:")
print("     ", bst_root.val)
print("   /     \\")
print(" ", bst_root.left.val, "     ", bst_root.right.val)
print("  / \\     /")
print(bst_root.left.left.val, "   ", bst_root.left.right.val, " ", bst_root.right.left.val)
print(" /   /     \\")

def canRepresentBST(arr):
    n = len(arr)

    lowerBound = []
    upperBound = []

    for i in range(n - 1, -1, -1):
        x = arr[i]

        if len(lowerBound) != 0 and x < lowerBound[-1]:
            return False

        while len(upperBound) != 0 and x > upperBound[-1]:
            lowerBound.append(upperBound.pop())

        upperBound.append(x)

    return True


# Test the implementation with the given examples
arr1 = [7, 4, 12, 3, 6, 8, 1, 5, 10]
arr2 = [11, 6, 13, 5, 12, 10]

print("Output1:", "Yes" if canRepresentBST(arr1) else "No")
print("Output2:", "Yes" if canRepresentBST(arr2) else "No")

